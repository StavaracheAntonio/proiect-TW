<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Documentatie TripInspire</title>
    <link rel="stylesheet" href="css/scholarly.min.css">
    <script src="js/scholarly.min.js"></script>
  </head>
  <body prefix="schema: http://schema.org">
    <header>
      <div class="banner">
        <img src="scholarly-html.svg" width="227" height="50" alt="Scholarly HTML logo">
        <div class="status">Web UAIC Iasi 2019</div>
      </div>
      <h1>Documentatie TripInspire</h1>
    </header>
    <div role="contentinfo">
      <dl>
        <dt>Authors</dt>
        <dd>
          Acsinte Matei Ionut
        </dd>
        <dd>
          Raducanu Andrei
        </dd>
        <dd>
          Stavarache Antonio
        </dd>  
    </div>

    <section typeof="sa:Cerinta" id="abstract" role="doc-cerinta">
      <h2>Cerinta</h2>
      <p>
        Să se creeze o aplicație Web care să ofere sugestii de călătorie pe baza unor constrângeri/preferințe, de exemplu: “doresc o vacanță activă de 7-10 zile la o temperatură mai mare de 20°C la mare” sau “doresc un city break în Europa care să coste mai puțin de 200 EUR de persoană”. Sistemul va gestiona diverse criterii de selectare. Pe baza acestor criterii, se vor monitoriza prețurile biletelor de avion pentru destinațiile ce se potrivesc, alertandu-se (via browser notifications) utilizatorii când criteriile sunt îndeplinite. Un utilizator poate avea una sau mai multe căutări de vacanțe active. Pentru implementare se poate folosi API-ul: https://docs.kiwi.com/
      </p>
    </section>
    <section id="introduction" role="doc-introduction">
      <!-- review? -->
      <h2>Motivatie</h2>
      <p>
        TripInspire este un intermediar intre clienti si agentiile de booking, lucru
        care il face foarte util in situatia data, in conditiile in care pentru alegerea
        unui simplu citybreak se consuma mai mult timp in cautari decat in vacanta propriu zisa,
        problema pe care aplicatia propusa o poate rezolva.
      </p>
    </section>
    <section id="structure">
      <!-- review? -->
      <h2>Structura</h2>
      <p>
       Partea de frontend a fost realizata in HTML,CSS si Javascript, iar cea de
       backend in PHP.
      </p>
      <p>
       Arhitecura aplicatiei a fost realizata pe baza design paternului MVC, aceasta fiind 
       despartita in 4 controllere de baza: Welcome, Home, Trip si Dasboard.
      </p>
      <p>
       Pentru interactiunea asincrona s-a folosit AJAX, iar pentru resurse externe si requesturi
       la resurse s-au folosit REST API-uri.
      </p>
      <section id="WelcomeController">
        <!-- review? -->
        <h3>Controllerul Welcome </h3>
        <p>
          Controller-ul Welcome preia un singur view si il afiseaza utilzatorului.
        </p>
    
      </section>
      <section id="HomeController">
        <!-- review? -->
        <h3>Controllerul Home</code></h3>
        <p>
          Controllerul Home contine 2 butoane, unul de login, iar celalalt de signup.
          De asemenea, acesta are un Trip Navigation Bar in care utilizatorul aplicatiei
          isi poate filtra excursiile in functie de o caracteristica ale acesteia.
          Pentru realizarea interactiunii asincrone la nivel de excursii s-a utilizat
          un AJAX, care apela un script de PHP, oferind ca parametru alegerea utilizatorului.
          Scriptul de PHP realiza conexiunea cu mai multe API-uri si consuma diverse functionalitati.
        <p>
          Teleport API care ne-a oferit informatii referitoare la descriere si imagini ale oraselor.
        </p>
        <p>
          Unsplash API respectiv Wikipedia API care oferea aceleasi informatii si erau folosite ca backup.
        </p>
        
      </section>
      <section id="TripController">
        <!-- review? -->
        <h3>Controllerul Trip</h3>
        <p>
          Dupa ce utilizitorul previzualizeaza excursiile dorite, acesta poate alege una dintre 
          ele pentru a afla informatii suplimentare despre aceasta, fiind redirectionat pe pagina
          Trip.
        </p>
        <p>
          Pargina excursie contine detalii suplimentare despre alegerea facuta si ii ofera utilizatorului
          facilitatea de a previzualiza zboruri din locatia sa curenta in locatia aleasa.
          Unele informatii ofera moneda curenta, vremea si limba, lucru care a fost
          facilitat de catre OpenWheaterMap si RestCountries.
        </p>
        <p>
         Daca acestuia ii convin ofertele poate sa le salveze si sa le vizualize in propria sa pagina
         de dashboard.
        </p>
        
      </section>
      <section id="DashboardController">
        <!-- review? -->
        <h3>Controllerul Dashboard</h3>
        <p>
          Controlul dashboard joaca mai mult rolul de UserPanel, acesta poate sa isi vizualizeze
          calatoriile alese precum sa isi schimbe anumite detalii ale contului.
        </p>
        <p>
          Calatoriile afisate in panou sunt cele pe care acesta le-a ales din panoul trip.
          Pentru a fi afisate se apeleaza metoda din modelul dasboard care afiseaza toate
          calatoriile ales de utilizatorul curent.
        </p>
      </section>
      <section id="Login & Register">
        <!-- review? -->
        <h3>Login & Register</h3>
        <p>
          Cand utilizatorul apasa butonul Login sau Register, se deschide un form care ii
          cere acestuia sa isi creeze un cont, respectiv, datele de autentificare ale contului.
        </p>
        <p>
          Acesta a fost realizat prin AJAX, datele de autentificare fiind trimise printr-un post
          la metodele de gestionare, care returneaza un JSON cu statusul failed sau success.
        </p>
        <p>
          Datele sunte verificate la input, injection free, iar parolele sunt criptate.
        </p>
      </section>

      <section id="interactive">
        
        <h3>API-uri & Resurse</h3>
        <p>
          Pentru stocare de imagini si descrieri de orase s-au folosit Teleport, Unsplash, WikiApi.
        </p>
        <p>
          Pentru informatii "cotidiene" despre locatii s-au folosit RestCountries.
        </p>
      </section>
    </section>
    <section id="semantics">
      
      <h2>Dezvoltarea proiectului</h2>
     
      <section id="dummy-data">
       
        <h3>"Dummy data"</h3>
        <p>
          In prima instanta am dorit sa populam baza de date cu tripuri prestabilite de catre noi
          si sa utilizam doar KiwiApi pentru cautarea zobrurilor.
        </p>
      </section>
      <section id="hash-trip">
        <!-- review? -->
        <h3>#trip</h3>
        <p>
         Ulterior ne-am gandit sa separam excursiile pe categorii pentru ca utilizatorul 
         sa filtreze mai usor informatia.
        </p>
      </section>
      <section id="requestBoom">
        <!-- review? -->
        <h3>Request BOOM</h3>
        <p>
          Dupa ce am utilizat api-urile prezentate mai sus, am reusit sa fitram cautarile 
          in functie de categorie, dar din pacate timpul de procesare al requesturilor era
          atat de mare in cat scripturile erau timed out.
        </p>
      </section>

      <section id="caching">
        <!-- review? -->
        <h3>Caching'n caching</h3>
        <p>
          Dupa ce am renuntat la opriunea de "a trai doar din api-uri" am ajuns la concluzia ca trebuie
          sa apelam scripturile de obtinere a informatiilor o singura data, sa le inseram in baza de date,
          iar datile viitoare cand vom avea nevoie, vom interoga baza de date, timpii de query fiind net superiori celor de request la resurse externe.
        </p>
      </section>

      <section id="caching">
        <h3>What's better in an API..than an API</h3>
        <p>
          Pentru realizarea paginii de City Description ne trebuiau informatii despre anumite orase ale lumii, pe care noi nu le stiam inca deoarece, cum am spus, baza de date este populata la "runtime" de catre Teleport, asa ca, pe baza endpointului dat de acesta, am apelat RestCities
          pentru a obtine informatii despre fiecare oras in parte.
        </p>
      </section>
    </section>
    <section id="final" role="doc-final">
      <!-- review? -->
      <h2>Conclusion</h2>
      <p>
        Dupa timpul depus si munca investita putem spune ca a fost un proiect "worth to work for".
        Produsul final este captivant, catchy si cu singuranta ar fi foarte util utilizatorui.
        In prima instanta, implementarea unui framework "from scratch" a fost putin dificila, dar, pe
        parcurs utilitatea acestuia se dovedea a fi din ce in ce mai mare.
      </p>
      <p>
        Separarea proiectului in mici bucatele a fost foarte utila pentru munca in echipa si integrarea
        a ajutat la a intelege cat de diferit este sa lucrezi pe un proiect de dimensiuni mari.
      </p>
      <p>This is our story, thank you for reading this and keep up de good work!</p>
    
  </body>
</html>
